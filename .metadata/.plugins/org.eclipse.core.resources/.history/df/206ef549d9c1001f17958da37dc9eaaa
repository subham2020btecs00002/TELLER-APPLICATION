package com.example.bank.controller;
import com.example.bank.dto.TransactionDTO;
import com.example.bank.model.Account;
import com.example.bank.model.Transaction;
import com.example.bank.repository.TransactionRepository;
import com.example.bank.service.TransactionService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/transactions")
@RequiredArgsConstructor
public class TransactionController {
    private final TransactionService transactionService;
    private final TransactionRepository transactionRepository;

 // Fetch all pending transactions
    @GetMapping("/pending")
    @PreAuthorize("hasAuthority('ROLE_AUTHORIZER')")
    public ResponseEntity<List<TransactionDTO>> getPendingTransactions() {
        List<Transaction> pendingTransactions = transactionRepository.findByStatus("PENDING");
        List<TransactionDTO> transactionDTOs = pendingTransactions.stream()
                .map(transaction -> new TransactionDTO(
                        transaction.getTransactionId(),
                        transaction.getAmount(),
                        transaction.getType(),
                        transaction.getAccount().getAccountId(),
                        transaction.getStatus() // Include status here
                ))
                .collect(Collectors.toList());
        return ResponseEntity.ok(transactionDTOs);
    }

    // Approve/Reject a transaction
    @PutMapping("/{transactionId}/approve")
    @PreAuthorize("hasAuthority('ROLE_AUTHORIZER')")
    public ResponseEntity<String> approveTransaction(
            @PathVariable Long transactionId,
            @RequestParam boolean approve) {
        transactionService.approveTransaction(transactionId, approve);
        return ResponseEntity.ok(approve ? "Transaction approved" : "Transaction rejected");
    }
    @PostMapping
    public ResponseEntity<Object> createTransaction(@RequestBody Transaction transaction) {
        if ("WITHDRAWAL".equalsIgnoreCase(transaction.getType())) {
            Account account = transaction.getAccount();
            double closingBalance = account.getClosingBalance();
            
            // Check for sufficient balance
            System.out.println(closingBalance);
            System.out.println(transaction.getAmount());

            if (closingBalance < transaction.getAmount()) {
                return ResponseEntity.badRequest().body("Insufficient balance for this withdrawal.");
            }
        }

        Transaction createdTransaction = transactionService.createTransaction(transaction,true);
        TransactionDTO transactionDTO = new TransactionDTO(
                createdTransaction.getTransactionId(),
                createdTransaction.getAmount(),
                createdTransaction.getType(),
                createdTransaction.getAccount().getAccountId(),
                createdTransaction.getStatus()
        );
        return ResponseEntity.ok(transactionDTO);
    }

    @GetMapping("/account/{accountId}")
    public ResponseEntity<List<TransactionDTO>> getTransactionsByAccountId(@PathVariable Long accountId) {
        List<Transaction> transactions = transactionService.getTransactionsByAccountId(accountId);
        List<TransactionDTO> transactionDTOs = transactions.stream()
                .map(transaction -> new TransactionDTO(
                        transaction.getTransactionId(),
                        transaction.getAmount(),
                        transaction.getType(),
                        transaction.getAccount().getAccountId(),
                        transaction.getStatus()
                ))
                .collect(Collectors.toList());
        return ResponseEntity.ok(transactionDTOs);
    }

}
